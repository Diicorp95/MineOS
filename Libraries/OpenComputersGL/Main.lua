local a=require("Color")local b=require("Vector")local c=require("Screen")local d=require("OpenComputersGL/Materials")local e=require("OpenComputersGL/Renderer")local f={}f.axis={x=1,y=2,z=3}f.colors={axis={x=0xFF0000,y=0x00FF00,z=0x0000FF},pivotPoint=0xFFFFFF,wireframe=0x000000,vertices=0xFFDB40,lights=0x44FF44}f.renderModes={disabled=1,constantShading=2,flatShading=3}f.auxiliaryModes={disabled=1,wireframe=2,vertices=3}f.renderMode=3;f.auxiliaryMode=1;f.vertices={}f.triangles={}f.lines={}f.floatingTexts={}f.lights={}local g,h={},{}function f.sin(i)g[i]=g[i]or math.sin(i)return g[i]end;function f.cos(i)h[i]=h[i]or math.cos(i)return h[i]end;function f.rotateVectorRelativeToXAxis(b,i)local j,k=f.sin(i),f.cos(i)b[2],b[3]=k*b[2]-j*b[3],j*b[2]+k*b[3]end;function f.rotateVectorRelativeToYAxis(b,i)local j,k=f.sin(i),f.cos(i)b[1],b[3]=k*b[1]+j*b[3],k*b[3]-j*b[1]end;function f.rotateVectorRelativeToZAxis(b,i)local j,k=f.sin(i),f.cos(i)b[1],b[2]=k*b[1]-j*b[2],j*b[1]+k*b[2]end;function f.translate(l,m,n)for o=1,#f.vertices do f.vertices[o][1],f.vertices[o][2],f.vertices[o][3]=f.vertices[o][1]+l,f.vertices[o][2]+m,f.vertices[o][3]+n end end;function f.rotate(p,i)for o=1,#f.vertices do p(f.vertices[o],i)end end;function f.newIndexedLight(q,r,s)return{q,r,s}end;function f.newIndexedTriangle(q,t,u,v)return{q,t,u,v}end;function f.newIndexedLine(q,t,a)return{q,t,a}end;function f.newIndexedFloatingText(w,a,x)return{w,x,a}end;function f.pushLightToRenderQueue(y,r,s)table.insert(f.vertices,y)table.insert(f.lights,f.newIndexedLight(f.nextVertexIndex,r,s))f.nextVertexIndex=f.nextVertexIndex+1 end;function f.pushTriangleToRenderQueue(z,A,B,v)table.insert(f.vertices,z)table.insert(f.vertices,A)table.insert(f.vertices,B)table.insert(f.triangles,f.newIndexedTriangle(f.nextVertexIndex,f.nextVertexIndex+1,f.nextVertexIndex+2,v))f.nextVertexIndex=f.nextVertexIndex+3 end;function f.pushLineToRenderQueue(z,A,a)table.insert(f.vertices,z)table.insert(f.vertices,A)table.insert(f.lines,f.newIndexedLine(f.nextVertexIndex,f.nextVertexIndex+1,a))f.nextVertexIndex=f.nextVertexIndex+2 end;function f.pushFloatingTextToRenderQueue(y,a,x)table.insert(f.vertices,y)table.insert(f.floatingTexts,f.newIndexedFloatingText(f.nextVertexIndex,a,x))f.nextVertexIndex=f.nextVertexIndex+1 end;function f.clearBuffer(C)f.nextVertexIndex,f.vertices,f.triangles,f.lines,f.floatingTexts,f.lights=1,{},{},{},{},{}e.clearDepthBuffer()c.clear(C)end;function f.createPerspectiveProjection()local D;for o=1,#f.vertices do D=math.abs(e.viewport.projectionSurface/f.vertices[o][3])f.vertices[o][1]=D*f.vertices[o][1]f.vertices[o][2]=D*f.vertices[o][2]end end;function f.getTriangleLightIntensity(E,F,G,H)local I={f.vertices[H[1]][1]-(E[1]+F[1]+G[1])/3,f.vertices[H[1]][2]-(E[2]+F[2]+G[2])/3,f.vertices[H[1]][3]-(E[3]+F[3]+G[3])/3}local J=b.length(I)if J<=H[3]then local K=b.getSurfaceNormal(E,F,G)local L=b.scalarMultiply({0,0,100},K)local M=b.scalarMultiply(I,K)if L<0 and M>=0 or L>=0 and M<0 then local N=math.abs(math.acos(M/(J*b.length(K))))if N>1.5707963267949 then N=3.1415926535898-N end;return H[2]*(1-J/H[3])*(1-N/1.5707963267949)else return 0 end else return 0 end end;function f.calculateLights()for O=1,#f.triangles do for P=1,#f.lights do local r=f.getTriangleLightIntensity(f.vertices[f.triangles[O][1]],f.vertices[f.triangles[O][2]],f.vertices[f.triangles[O][3]],f.lights[P])if f.triangles[O][5]then f.triangles[O][5]=f.triangles[O][5]+r else f.triangles[O][5]=r end end end end;function f.render()local E,F,G,v,Q={},{},{}for O=1,#f.triangles do E[1],E[2],E[3]=e.viewport.xCenter+f.vertices[f.triangles[O][1]][1],e.viewport.yCenter-f.vertices[f.triangles[O][1]][2],f.vertices[f.triangles[O][1]][3]F[1],F[2],F[3]=e.viewport.xCenter+f.vertices[f.triangles[O][2]][1],e.viewport.yCenter-f.vertices[f.triangles[O][2]][2],f.vertices[f.triangles[O][2]][3]G[1],G[2],G[3]=e.viewport.xCenter+f.vertices[f.triangles[O][3]][1],e.viewport.yCenter-f.vertices[f.triangles[O][3]][2],f.vertices[f.triangles[O][3]][3]v=f.triangles[O][4]if e.isVertexInViewRange(E[1],E[2],E[3])or e.isVertexInViewRange(F[1],F[2],F[3])or e.isVertexInViewRange(G[1],G[2],G[3])then if v.type==d.types.solid then if f.renderMode==f.renderModes.constantShading then e.renderFilledTriangle({E,F,G},v.color)elseif f.renderMode==f.renderModes.flatShading then local R,S,T=a.integerToRGB(v.color)R,S,T=math.floor(R*f.triangles[O][5]),math.floor(S*f.triangles[O][5]),math.floor(T*f.triangles[O][5])if R>255 then R=255 end;if S>255 then S=255 end;if T>255 then T=255 end;f.triangles[O][5]=nil;e.renderFilledTriangle({E,F,G},a.RGBToInteger(R,S,T))end elseif v.type==d.types.textured then E[4],E[5]=f.vertices[f.triangles[O][1]][4],f.vertices[f.triangles[O][1]][5]F[4],F[5]=f.vertices[f.triangles[O][2]][4],f.vertices[f.triangles[O][2]][5]G[4],G[5]=f.vertices[f.triangles[O][3]][4],f.vertices[f.triangles[O][3]][5]e.renderTexturedTriangle({E,F,G},v.texture)else error("Material type "..tostring(v.type).." doesn't supported for rendering triangles")end;if f.auxiliaryMode~=f.auxiliaryModes.disabled then E[1],E[2],E[3]=math.floor(e.viewport.xCenter+f.vertices[f.triangles[O][1]][1]),math.floor(e.viewport.yCenter-f.vertices[f.triangles[O][1]][2]),math.floor(f.vertices[f.triangles[O][1]][3])F[1],F[2],F[3]=math.floor(e.viewport.xCenter+f.vertices[f.triangles[O][2]][1]),math.floor(e.viewport.yCenter-f.vertices[f.triangles[O][2]][2]),math.floor(f.vertices[f.triangles[O][2]][3])G[1],G[2],G[3]=math.floor(e.viewport.xCenter+f.vertices[f.triangles[O][3]][1]),math.floor(e.viewport.yCenter-f.vertices[f.triangles[O][3]][2]),math.floor(f.vertices[f.triangles[O][3]][3])if f.auxiliaryMode==f.auxiliaryModes.wireframe then e.renderLine(E[1],E[2],E[3],F[1],F[2],F[3],f.colors.wireframe)e.renderLine(F[1],F[2],F[3],G[1],G[2],G[3],f.colors.wireframe)e.renderLine(E[1],E[2],E[3],G[1],G[2],G[3],f.colors.wireframe)elseif f.auxiliaryMode==f.auxiliaryModes.vertices then e.renderDot(E[1],E[2],E[3],f.colors.vertices)e.renderDot(F[1],F[2],F[3],f.colors.vertices)e.renderDot(G[1],G[2],G[3],f.colors.vertices)end end end end;if f.auxiliaryMode~=f.auxiliaryModes.disabled then for P=1,#f.lights do e.renderDot(math.floor(e.viewport.xCenter+f.vertices[f.lights[P][1]][1]),math.floor(e.viewport.yCenter-f.vertices[f.lights[P][1]][2]),math.floor(f.vertices[f.lights[P][1]][3]),f.colors.lights)end end;for U=1,#f.floatingTexts do E=f.vertices[f.floatingTexts[U][1]]e.renderFloatingText(e.viewport.xCenter+E[1],e.viewport.yCenter-E[2],E[3],f.floatingTexts[U][2],f.floatingTexts[U][3])end end;local function V(W,T)return b.newVector3(W[2]*T[3]-W[3]*T[2],W[3]*T[1]-W[1]*T[3],W[1]*T[2]-W[2]*T[1])end;local function X(W)return math.sqrt(W[1]^2+W[2]^2+W[3]^2)end;function f.triangleRaycast(Y,Z)local _,a0;for O=1,#f.triangles do local a1,a2,a3=f.vertices[f.triangles[O][1]],f.vertices[f.triangles[O][3]],f.vertices[f.triangles[O][3]]local a4=V(b.newVector3(a3[1]-a1[1],a3[2]-a1[2],a3[3]-a1[3]),b.newVector3(a2[1]-a1[1],a2[2]-a1[2],a2[3]-a1[3]))local a5=-a4[1]*a1[1]-a4[2]*a1[2]-a4[3]*a1[3]local a6=a5+a4[1]*Y[1]+a4[2]*Y[2]+a4[3]*Y[3]local a7=a4[1]*Y[1]-a4[1]*Z[1]+a4[2]*Y[2]-a4[2]*Z[2]+a4[3]*Y[3]-a4[3]*Z[3]if a7~=0 then local a8=a6/a7;if a8>=0 and a8<=1 and(not _ or a8<_)then local a9=b.newVector3(Y[1]+(Z[1]-Y[1])*a8,Y[2]+(Z[2]-Y[2])*a8,Y[3]+(Z[3]-Y[3])*a8)local aa=b.newVector3(a1[1]-a9[1],a1[2]-a9[2],a1[3]-a9[3])local ab=b.newVector3(a2[1]-a9[1],a2[2]-a9[2],a2[3]-a9[3])local ac=b.newVector3(a3[1]-a9[1],a3[2]-a9[2],a3[3]-a9[3])local ad=X(V(aa,ab))+X(V(ab,ac))+X(V(ac,aa))local ae=X(a4)if math.abs(ad-ae)<1 then a0=O;_=a8 end end end end;if f.triangles[a0]then return f.triangles[a0][5],f.triangles[a0][6],_ end end;return f
